\subsection{Vzdálenost vrcholů}
\label{ssec:vzdalenost-vrcholu}

Sekci motivujeme úlohou \uv{jako ze života}, která ve mně budí jistou míru
nostalgie, jelikož jsem ji řešil na konci prvního ročníku v rámci zkoušky
z~programování. Dovolil jsem si ji ovšem literárně obohatit.

\begin{problem}[Rodinný výlet]
 \label{prob:rodinny-vylet}
 Je prodloužený víkend a slezská rodina Koláčků plánuje cyklistický výlet
 oblastí Karviná. Jedou děda Koláček se svou chotí, babičkou Koláčkovou, a
 jejich čtyři uřvaná rozmazlená vnoučata -- Matouš, Marek, Lukáš a Jan.

 Z Třince do Orlové dánť jest směr a, i přes relativní nenáročnost terénu,
 vnoučata ustavičně fňukají, že chtějí jet tou nejkratší trasou. Děda Koláček,
 dobrodinec ten od kosti, snaží se vnoučatům vyhovět a nejkratší trasu úpěnlivě
 hledá. Do vřavy se přidává babička Koláčková, která ví, že trasa z Třince do
 Orlové vede přes mnoho malých vesnic, mnohože~z nich hostí aspoň jednu hospodu.

 Vědouc velmi dobře, že každá hospoda zbrzdí cestu na nejméně půl hodiny a že i
 při mimoděčné zmínce o blízké hospodě si děda Koláček počíná mnouti pivní
 pupek, trvá babička Koláčková na tom, aby vybraná cesta z Třince do Orlové
 vedla přes vesnice, které jsou tak daleko od hospod, jak je to jen možné. Křik
 vnoučat brzy ji však přesvědčí, že délka trasy převažuje nad množstvím hospod,
 ke kterým se po cestě přiblíží.

 Koláčkovic rodina tudíž stojí před nelehkým úkolem vybrat ze všech nejkratších
 cest z Třince do Orlové tu, která je hospodám co nejvíce vzdálena.

 Brzy znaven, děda Koláček posílá nezkrotná vnoučata s konečně neosedlanými
 bicykly domů a výlet do Orlové se odkládá na příští školní prázdniny. Pomozme
 mu jej zorganizovat předem.
\end{problem}

Úlohu si modelujeme ohodnoceným grafem $G = (V,E,w)$. Vrcholy představují
vesnice, případně města, mezi Třincem a Orlovou, z nichž některé jsou označeny
vykřičníkem mínícím přítomnost jedné či více hospod.

\begin{figure}[h]
 \centering
 \begin{tikzpicture}[scale=1.5]
  \node[vertex,myred] (t) at (0, 0) {};
  \node[vertex] (v11) at (1, 1) {};
  \node[vertex] (v12) at (1, -1) {};
  \node[vertex] (v21) at (2, 0.5) {};
  \node[vertex,mypurple] (v22) at (2, -0.5) {};
  \node[vertex] (v23) at (2, -2) {};
  \node[vertex,mypurple] (v31) at (3, 1.5) {};
  \node[vertex] (v32) at (3, 0) {};
  \node[vertex,mypurple] (v33) at (3, -1) {};
  \node[vertex,mypurple] (v41) at (4, 2) {};
  \node[vertex] (v42) at (4, 1) {};
  \node[vertex] (v43) at (4, -0.5) {};
  \node[vertex] (v44) at (4, -1.5) {};
  \node[vertex,myblue] (o) at (5, 0) {};

  \draw[thick] (t) to node[midway,draw,circle,fill=white,inner sep=1pt]
   {\footnotesize $4$} (v11);
  \draw[thick] (t) to node[midway,circle,draw,fill=white,inner sep=1pt]
   {\footnotesize $3$} (v12);
  \draw[thick] (v11) to node[midway,circle,draw,fill=white,inner sep=1pt]
   {\footnotesize $2$} (v21);
  \draw[thick] (v11) to node[midway,circle,draw,fill=white,inner sep=1pt]
   {\footnotesize $7$} (v22);
  \draw[thick] (v12) to node[midway,circle,draw,fill=white,inner sep=1pt]
   {\footnotesize $3$} (v22);
  \draw[thick] (v12) to node[midway,circle,draw,fill=white,inner sep=1pt]
   {\footnotesize $6$} (v23);
  \draw[thick] (v23) to node[midway,circle,draw,fill=white,inner sep=1pt]
   {\footnotesize $2$} (v44);
  \draw[thick] (v11) to node[midway,circle,draw,fill=white,inner sep=1pt]
   {\footnotesize $12$} (v31);
  \draw[thick] (v21) to node[midway,circle,draw,fill=white,inner sep=1pt]
   {\footnotesize $5$} (v31);
  \draw[thick] (v21) to node[midway,circle,draw,fill=white,inner sep=1pt]
   {\footnotesize $3$} (v32);
  \draw[thick] (v22) to node[midway,circle,draw,fill=white,inner sep=1pt]
   {\footnotesize $4$} (v32);
  \draw[thick] (v23) to node[midway,circle,draw,fill=white,inner sep=1pt]
   {\footnotesize $5$} (v33);
  \draw[thick] (t) to node[midway,circle,draw,fill=white,inner sep=1pt]
   {\footnotesize $8$} (v22);
  \draw[thick] (v22) to node[midway,circle,draw,fill=white,inner sep=1pt]
   {\footnotesize $6$} (v23);
  \draw[thick] (v32) to node[midway,circle,draw,fill=white,inner sep=1pt]
   {\footnotesize $3$} (v33);
  \draw[thick] (v31) to node[midway,circle,draw,fill=white,inner sep=1pt]
   {\footnotesize $4$} (v41);
  \draw[thick] (v31) to node[midway,circle,draw,fill=white,inner sep=1pt]
   {\footnotesize $3$} (v42);
  \draw[thick] (v32) to node[midway,circle,draw,fill=white,inner sep=1pt]
   {\footnotesize $5$} (v42);
  \draw[thick] (v32) to node[midway,circle,draw,fill=white,inner sep=1pt]
   {\footnotesize $3$} (v43);
  \draw[thick] (v33) to node[midway,circle,draw,fill=white,inner sep=1pt]
   {\footnotesize $4$} (v43);
  \draw[thick] (v33) to node[midway,circle,draw,fill=white,inner sep=1pt]
   {\footnotesize $3$} (v44);
  \draw[thick] (v21) to node[midway,circle,draw,fill=white,inner sep=1pt]
   {\footnotesize $7$} (v42);
  \draw[thick] (v41) to node[midway,circle,draw,fill=white,inner sep=1pt]
   {\footnotesize $14$} (o);
  \draw[thick] (v42) to node[midway,circle,draw,fill=white,inner sep=1pt]
   {\footnotesize $7$} (o);
  \draw[thick] (v32) to node[midway,circle,draw,fill=white,inner sep=1pt]
   {\footnotesize $11$} (o);
  \draw[thick] (v43) to node[midway,circle,draw,fill=white,inner sep=1pt]
   {\footnotesize $5$} (o);
  \draw[thick] (v44) to node[midway,circle,draw,fill=white,inner sep=1pt]
   {\footnotesize $9$} (o);

  \node[below left=0mm of t,myred] (tlabel) {$t$};
  \node[below right=0mm of o,myblue] (olabel) {$o$};
 
  \node[above right=-1mm and -2mm of v22,mypurple] {$\mathbf{!}$};
  \node[above left=-1mm and -1mm of v31,mypurple] {$\mathbf{!}$};
  \node[above left=-3mm and -1mm of v33,mypurple] {$\mathbf{!}$};
  \node[above right=-1mm and -1mm of v41,mypurple] {$\mathbf{!}$};
  
 \end{tikzpicture}
 \caption{Graf obcí mezi \clr{Třincem} a \clb{Orlovou}.}
 \label{fig:trinec-orlova}
\end{figure}

Nejprve se soustředíme na nejpodstatnější část úlohy, tou jest nalezení
nejkratší cest mezi Třincem a Orlovou, kterážto města si v zájmu strohosti
označíme písmeny $t,o \in V$.

První, co by člověka mohlo napadnout je spustit
\hyperref[alg:floyd-warshall]{Floydův-Warshallův algoritmus}. Zde je však nutno
si uvědomit, že ten není možné modifikovat tak, aby hledal vzdálenost mezi dvěma
konkrétními vrcholy. Totiž, z~popisu jeho průběhu plyne, že váhu nejkratší cesty
mezi dvěma vrcholy, která vede pouze přes vrcholy z množiny
$\{v_1,\ldots,v_k\}$, umím spočítat teprve tehdy, když znám váhy nejkratších
cest používajících pouze vrcholy $v_1,\ldots,v_{k-1}$ mezi \textbf{všemi
dvojicemi vrcholů} v grafu $G = (\{v_1,\ldots,v_n\}, E, w)$. Odtud plyne, že
Floydův-Warshallův algoritmus potřebuje znát zatím nejkratší nalezenou cestu
mezi každými dvěma vrcholy, aspoň dokud $k$ není $n$.

Samozřejmě je též možné najít \textbf{všechny} cesty mezi danými dvěma vrcholy a
z nich vybrat tu nejkratší. Tento postup je však ještě výrazně méně efektivní
než Floydův-Warshallův algoritmus.

Není však radno zoufat, bo algoritmus pro relativně efektivní nalezení
vzdálenosti mezi určenými dvěma vrcholy v grafu existuje. Nosí jméno svého
tvůrce, holandského informatika a programátora Edsgera W. Dijk\-stry (čteno
\uv{dajkstry}). Není složitý, ale zcela jistě je méně přímočarý než
\hyperref[alg:kruskal]{Kruskalův} i
\hyperref[alg:floyd-warshall]{Floydův-Warshallův} algoritmus.

Pozastavme se na moment a oceňme tu ironii, že najít efektivní algoritmus na
výpočet vzdálenosti mezi dvě\-ma vrcholy je výrazně obtížnější než na výpočet
vzdálenosti mezi všemi dvojicemi vrcholů.

\subsubsection{Dijkstrův algoritmus}
\label{sssec:dijkstruv-algoritmus}

Dijkstrův algoritmus má mnoho společného s
\hyperref[alg:floyd-warshall]{Floydovým-Warshallovým algoritmem}, například
rovněž v každém kroku zlepšuje zatím nejlepší známou vzdálenost od
\emph{zdrojového} vrcholu k ostatním. Jeho základní myšlenka je však jiná.
Dijkstrův algoritmus využívá tzv. \uv{průchod do šířky}, což znamená, že se
\uv{šíří} od jednoho zvoleného \emph{zdrojového vrcholu} nejprve do jeho sousedů
(tj. do vrcholů s ním spojených hranou). Při průchodu si u každého vrcholu
pamatuje zatím nejlepší nalezenou cestu ze zdrojového vrcholu do něj, a kdykoli
vstoupí do dalšího vrcholu, ověří, zda cesta, po které se do něj dostal, není
kratší než dosavad nejlepší.

Tento postup sám není nijak revoluční a průchod do šířky je asi tak starý jako
grafy samotné. Myšlenka, se kterou Edsger Dijkstra přišel, však na svou dobu
revoluční byla, neboť se jednalo o tehdy nejefektivnější způsob nalezení
vzdálenosti mezi vrcholy v ohodnoceném grafu. U každého vrcholu si pamatoval
váhu zatím nejkratší nalezené cesty od zdroje k němu. Uvědomil si, že
\textbf{pokud vybírá vrcholy vždy od těch s minimální uloženou hodnotou}, tak v
moment, \textbf{kdy projde všechny sousedy nějakého vrcholu}, pak už \textbf{je
zapamatovaná hodnota v tomto vrcholu nejlepší možná}, tedy se jedná o skutečnou
vzdálenost od zdroje k tomuto vrcholu a už se do něj nikdy nemusí znovu vracet.

Důvod, proč tomu tak je, není na první pohled zřejmý a objasníme ho podrobně v
důkazu správnosti Dijkstrova algoritmu.

Ještě před slovním popisem a představením pseudokódu je dobré se zamyslet, o
kolik více efektivní je Dijkstrův způsob oproti prostému průchodu do šířky. Pro
úplnost:
\begin{itemize}
 \item Průchod do šířky vždy putuje od vrcholu ke všem jeho sousedům, od těch
  zase k jejich sousedům a tak dále. Tedy se mnohokrát může (a \textbf{musí},
  aby našel opravdu nejkratší cestu) vracet do vrcholů, které již prošel, v
  moment, kdy do nich přes nějaké vrcholy dříve navštívené vede cesta.
 \item Dijkstrův algoritmus nahlédne z právě vybraného vrcholu do jeho sousedů,
  ale pak nepokračuje nutně jimi. Naopak, právě vybraný vrchol již \uv{uzamkne}
  a pokračuje nějakým s minimální uloženou zatím nejkratší cestou ze zdroje do
  něj.
\end{itemize}
Kvůli tomu, že přes sousedy každého vrcholu může zpět do něj vést nějakou
oklikou cesta zpátky, projdu při běžném průchodu do šířky úplně všechny cesty v
grafu $G$.

Naopak, Dijkstrův algoritmus \emph{zakazuje} vracet se do vrcholů, jejichž
všichni sousedi již byli navštíveni. Tedy, každý vrchol je navštíven v nejhorším
tolikrát, kolik má sousedů. Je snadné si rozmyslet, o kolik je (řádově)
v~průměrném případě počet sousedů vrcholu nižší než počet cest jím
procházejících.

Největší časový rozdíl mezi obvyklým průchodem do šířky a Dijkstrovým algoritmem
je vidět v tzv. \emph{úplných grafech}, tedy grafech, ve kterých je každý vrchol
spojen s každým. V úplném grafu na $n$ vrcholech, který se často značí $K_n$,
definuje libovolná podmnožina vrcholů cestu. Již dlouho víme, že všech podmnožin
množiny o $n$ prvcích je $2^{n}$. Tedy, algoritmus průchodu do šířky udělá při
hledání vzdálenosti mezi dvěma vrcholy v úplném grafu vždy $2^{n}$ kroků. Oproti
tomu, Dijkstrův algoritmus udělá v grafu na $n$ vrcholech vždy nejvýše $n(n-1)$
kroků, protože každý vrchol má nejvýše $n$ sousedů. Už jen pro graf na $10$
vrcholech je číslo $10 \cdot 9$ přibližně $900$krát menší než číslo $2^{10}$.

Na \myref{obrázku}{fig:uplny-graf} vidíte úplný graf na $5$ vrcholech. Upřímně
doporučuji, abyste si tvrzení předchozího odstavce vyzkoušeli v praxi.

\begin{figure}[h]
 \centering
 \begin{tikzpicture}
  \node[vertex,myred] (1) at (90:2) {};
  \node[vertex] (2) at (162:2) {};
  \node[vertex] (3) at (234:2) {};
  \node[vertex,myblue] (4) at (306:2) {};
  \node[vertex] (5) at (18:2) {};
  
  \foreach \i in {1,2,...,5} {
   \foreach \j in {1,2,...,5} {
    \ifthenelse{\equal{\i}{\j}}{}{
     \tikzmath{
      integer \w;
      \w = \i + \j;
     }
     \draw[thick] (\i) to node[midway,circle,draw,fill=white,inner sep=1pt]
      {\footnotesize $\w$} (\j);
    }
   }
  }
 \end{tikzpicture}

 \caption{Ohodnocený úplný graf na pěti vrcholech s vyznačeným \clr{zdrojovým} a
 \clb{cílovým} vrcholem.}
 \label{fig:uplny-graf}
\end{figure}

Nyní přistoupíme ke slovnímu popisu Dijkstrova algoritmu. Algoritmus striktně
vzato nepočítá vzdálenost mezi dvěma vrcholy, anobrž vzdálenost od
\emph{zdrojového vrcholu} ke všem ostatním.

Podobně jako \hyperref[alg:floyd-warshall]{Floydův-Warshallův algoritmus}, i
Dijkstrův algoritmus vytváří postupně zobrazení $d:V \to [0,\infty]$ takové, že
po jeho skončení platí $d(v) = d_G(s,v)$ pro všechna $v \in V$ a nějaký pevně
zvolený zdrojový vrchol $s \in V$. Na začátku algoritmu je pročež $d(s) = 0$ a
$d(v) = \infty$ pro všechny $s \neq v \in V$. V každém kroku algoritmu navíc
existuje množina $X$ \uv{zakázaných} vrcholů, do kterých už není možné se dívat
ani vracet. V moment, kdy procházím sousedy právě vybraného vrcholu, ignoruji
ty, které již byly někdy zakázány.

Jeden krok algoritmu vypadá takto:
\begin{enumerate}
 \item Označ jako zvolený vrchol libovolný $v \in V$ \textbf{s minimální
  $d(v)$}.
 \item Pro každého souseda $u$ zvoleného vrcholu $v$ porovnej zatím nejkratší
  známou cestu z $s$ do $u$, to jest $d(u)$, s váhou zatím nejkratší cesty z $s$
  do $u$ vedoucí přes $v$, to jest $d(v) + w(uv)$. Je-li druhá hodnota menší,
  změň $d(u)$ na $d(v) + w(uv)$.
 \item Vrchol $v$ označ jako zakázaný.
 \item Pokud ještě existuje vrchol, který není zakázaný, opakuj (1).
\end{enumerate}

Jak jsme již psali -- fakt, že jako další vrchol v pořadí volíme ten s minimální
známou nejkratší cestou z $s$, umožňuje se nikdy do vrcholů, jejichž sousedy
projdeme, nevracet, není samozřejmý. Výklad o obecném chodu Dijkstrova algoritmu
zakončíme prezentací jeho pseudokódu pro \textbf{souvislý} ohodnocený graf $G =
(V,E,w)$ s pevně zvoleným zdrojovým vrcholem $s \in V$. Ihned poté dokážeme jeho
správnost.

\begin{remark}
 Stejně jako \hyperref[alg:floyd-warshall]{Floydův-Warshallův algoritmus}, ani
 Dijkstrův  algoritmus neselže pro nesouvislé grafy, ale všem vrcholům $v \in V$
 nedosažitelným z $s$ zůstane hodnota $d(v) = \infty$, tedy je zcela zbytné
 nesouvislé grafy uvažovat.
\end{remark}

Pro stručnost vyjádření zavedeme ještě značení
\[
 n(v) \coloneqq \{u \in V \mid uv \in E\},
\]
čili označíme výrazem $n(v)$ (od angl. \emph{\textbf{n}eighbour}), množinu všech
sousedů vrcholu $v \in V$.

\begin{algorithm}
 \caption{Dijkstrův algoritmus}
 \label{alg:dijkstra}

 \SetKwInOut{Input}{input}
 \SetKwInOut{Output}{output}
 \SetKw{KwReturn}{return}

 \Input{souvislý ohodnocený graf $G = (V,E,w)$ s počátečním vrcholem $s \in V$}
 \Output{zobrazení $d:V \to [0,\infty]$ takové, že $d \equiv d_G(s,-)$}
 \BlankLine
 \emph{Inicializace}\;
 $d(s) \leftarrow 0$\;
 \For{$v \in V \setminus \{s\}$} {
  $d(v) \leftarrow \infty$\;
 }
 $X \leftarrow \emptyset$\;
 \BlankLine
 \emph{Pokračuj, dokud existují nezakázané vrcholy}\;
 \While{$X \neq V$} {
  \emph{Najdi vrchol s minimální zatím nejlepší známou vzdáleností od $s$}\;
  $v \leftarrow $ libovolný vrchol s minimální $d(v)$ takový, že $v \notin X$\;
  \emph{Projdi všechny jeho sousedy, kteří nejsou zakázáni}\;
  \For{$u \in n(v) \setminus X$} {
   \emph{Pokud do $u$ vede přes $v$ kratší cesta, změň $d(u)$ na její váhu}\;
   \If{$d(u) > d(v) + w(uv)$} {
    $d(u) \leftarrow d(v) + w(uv)$\;
   }
  }
  \emph{Po průchodu všech sousedů, zakaž $v$}\;
  $X \leftarrow X \cup \{v\}$\;
 }
 \KwReturn{$d$}\;
\end{algorithm}

\pagebreak

\begin{remark}
 Pokud bychom chtěli použít Dijkstrův algoritmus na nalezení vzdálenosti mezi
 dvěma konkrétními vrcholy $s,t \in V$, pak stačí \texttt{while} cyklus v
 \hyperref[alg:dijkstra]{pseudokódu výše} zastavit v moment, kdy $t \in X$. Pak
 už je totiž známa hodnota $d_G(s,t)$, kterou jsme chtěli spočítat.

 Povšimněte si, že v tomto případě ještě k naprosté efektivitě Dijkstro\-vě
 algoritmu krůček schází. Totiž, cestou od $s$ do $t$ projde velmi mnoho vrcholů
 blízkých $s$, přes které \uv{víme}, že nejkratší cesta z $s$ do $t$ vést
 nemůže. Algoritmy používané například v GPS aplikacích staví částečně na
 principu Dijkstrova algoritmu, ale tento nedostatek většinově odstraňují.
 Jejich popis je však zároveň nad rámec tohoto textu.
\end{remark}

\begin{claim}
 \label{claim:dijsktra-korektni}
 Dijkstrův algoritmus je korektní.
\end{claim}
\begin{proof}
 Musíme ověřit, že Dijkstrův algoritmus je konečný a počítá správně.

 Konečnost je zřejmá. Vrchol $v \in V$ s minimální $d(v)$ vždy existuje (i kdyby
 ta hodnota měla být $\infty$), a tedy nastane chvíle, kdy v $X$ jsou všechny
 vrcholy grafu $G$. V ten moment $X = V$, cyklus končí a algoritmus vrací
 zobrazení $d$.
 
 Korektnost ukážeme indukcí podle počtu zakázaných vrcholů, tedy podle $\# X$.
 Naším indukčním předpokladem bude, jako tomu obvykle v důkazech indukcí bývá,
 že algoritmus funguje. To přesně znamená, že v každém kroku
 \begin{enumerate}[label=(\alph*)]
  \item je $d(v) = d_G(s,v)$ pro všechny vrcholy $v \in X$;
  \item je $d(u)$ váha nejkratší cesty z $s$ do $u$ vedoucí pouze přes vrcholy v
   $X$, pro všechna $u \in V \setminus X$.
 \end{enumerate}
 Předpoklad (a) říká v lidské mluvě, že zakazování vrcholů si opravdu můžeme
 dovolit, tedy že do zakázaných vrcholů již nejde nalézt kratší cestu.

 Význam předpokladu (b) je těžší dekódovat. Představme si spíše, co by se stalo,
 kdyby \textbf{neplatil}. Pak by existovala nějaká kratší cesta do nezakázaného
 vrcholu $u$ přes zakázané vrcholy. Ovšem, přesně pro to, že tyto vrcholy jsou
 již zakázané, nemohu během zbytku průběhu algoritmu již nikdy tuto cestu
 objevit. Pokud by se pro nějaký $u \in V$ stalo, že zrovna tato cesta je tou
 nejkratší, pak již zároveň nemohu nalézt hodnotu $d_G(s,u)$ a algoritmus selže.

 Počáteční případ $\# X = 1$ je snadný. V tomto stádiu jsme zrovna zakázali
 zdrojový vrchol $s$ a pro každého jeho souseda $u$ jsme položili $d(u) =
 w(su)$, jelikož $d(s) = 0$ a $d(u)$ bývala hodnota $\infty$. Tedy, zakázaný
 vrchol je jedině $s$ a $d(s) = d_G(s,s) = 0$, čímž jsme ověřili platnost (a).
 Jediné vrcholy, do nichž vede cesta přes zakázané vrcholy, tedy přes vrchol
 $s$, jsou sousedé $s$, a váha nejkratší cesty je zřejmě $w(su)$ pro každého
 souseda $u \in n(s)$. To dokazuje (b).

 Nyní předpokládejme, že (a) i (b) platí pro $X$ a zakažme nějaký zatím
 nezakázaný vrchol $u \in V \setminus X$. Dokážeme nejprve platnost (a).
 Z~indukčního předpokladu platí (a) pro všechny vrcholy $X$ kromě nově přidaného
 $u$, tedy stačí ukázat, že (a) platí i pro $u$.

 Dokazujme tedy, že $d(u) = d_G(s,u)$. Budeme postupovat sporem. Ať tedy tato
 rovnost neplatí. Pak existuje nenalezená nejkratší cesta $\mathcal{P}$ z $s$ do
 $u$ a platí $w(\mathcal{P}) < d(u)$. Rozlišíme dva případy.
 \begin{enumerate}[label=(\arabic*)]
  \item $\mathcal{P}$ prochází nějakými nezakázanými vrcholy.
  \item $\mathcal{P}$ neprochází žádným nezakázaným vrcholem (tedy všechny její
   vrcholy jsou v $X$).
 \end{enumerate}
 Ať nastala možnost (1). Označme písmenem $w$ \textbf{první nezakázaný} vrchol
 na cestě $\mathcal{P}$ (směrem od $s$). Z indukčního předpokladu (b) jsou
 $d(w)$ a $d(u)$ váhy nejkratší cest z $s$ do $w$, resp. z $s$ do $u$, vedoucích
 jen přes vrcholy z $X$. To ale znamená, že $d(u)$ je aspoň tolik, co $d(w)$ +
 váha nejkratší cesty z~$w$ do $u$. Protože váha nejkratší cesty z $w$ do $u$ je
 jistě kladné číslo, plyne odtud, že $d(u) > d(w)$. Ovšem, $w$ není zakázaný a
 algoritmus prochází nezakázané vrcholy postupně od těch s~minimální váhou zatím
 nejkratší známé cesty z $s$ do nich. Algoritmus navštívil $u$ dříve než $w$,
 pročež $d(u) \leq d(w)$. Pak ale máme
 \[
  d(w) < d(u) \leq d(w),
 \]
 což je zřejmý spor. Vizte \myref{obrázek}{subfig:dukaz-dijkstra-pripad-1}.

 Nyní ať nastala možnost (2). Ať $w$ je \textbf{předposlední} vrchol na cestě
 $\mathcal{P}$ (tedy ten těsně před $u$). Protože $w$ je zakázaný, platí $d(w) =
 d_G(s,w)$ z indukčního předpokladu (a). Pak ale $w(\mathcal{P}) = d(w) + w(wu)
 < d(u)$. To je ovšem spor, protože $u$ je sousedem $w$ a $w$ byl zakázán dříve
 než $u$, a tedy algoritmus měl při procházení sousedů $w$ nastavit hodnotu
 $d(u)$ na $d(w) + w(wu)$. Vizte
 \myref{obrázek}{subfig:dukaz-dijkstra-pripad-2}.

 Zbývá ověřit platnost (b) pro $X \cup \{u\}$. Z indukčního předpokladu platí
 (b) pro všechny vrcholy z $V \setminus X$ kromě sousedů $u$, protože pro ty
 jsme přidáním $u$ žádnou novou cestu přes zakázané vrcholy nenašli. Pro sousedy
 $u$ však platí (b) zřejmě také, protože pokud do nich existuje přes $u$ kratší
 cesta, tak u nich algoritmus váhu zatím nejkratší známé cesty z $s$ změnil na
 váhu této kratší cesty přes $u$.

 Tím je důkaz správnosti Dijkstrova algoritmu indukcí podle $\# X$ dokončen.
\end{proof}

\begin{figure}[h]
 \centering
 \begin{subfigure}{.47\textwidth}
  \centering
  \begin{tikzpicture}[scale=1.25]
   \node[vertex,myred] (s) at (0, 0) {};
   \node[vertex,myred] (v1) at (1, -1) {};
   \node[vertex,myred] (v2) at (2, -1) {};
   \node[vertex,myred] (v3) at (3,-1.5) {};
   \node[vertex,myred] (u) at (4, 0) {};

   \node[vertex,myred] (p1) at (1, 1) {};
   \node[vertex,myred] (p2) at (2, 0.5) {};
   \node[vertex] (w) at (3, 1.5) {};
   
   \node[below left=0mm and 0mm of s,myred] {$s$};
   \node[below right=0mm and 0mm of u,myred] {$u$};
   \node[above right=0mm and 0mm of w] {$w$};

   \draw[thick] (s) to node[midway,circle,draw,fill=white,inner sep=1pt]
    {\footnotesize $4$} (v1);
   \draw[thick] (v1) to node[midway,circle,draw,fill=white,inner sep=1pt]
    {\footnotesize $2$} (v2);
   \draw[thick] (v2) to node[midway,circle,draw,fill=white,inner sep=1pt]
    {\footnotesize $1$} (v3);
   \draw[thick] (v3) to node[midway,circle,draw,fill=white,inner sep=1pt]
    {\footnotesize $4$} (u);
   
   \draw[thick,myblue] (s) to node[midway,circle,draw,fill=white,inner sep=1pt]
    {\footnotesize $3$} (p1);
   \draw[thick,myblue] (p1) to node[midway,circle,draw,fill=white,inner sep=1pt]
    {\footnotesize $3$} (p2);
   \draw[thick,myblue] (p2) to node[midway,circle,draw,fill=white,inner sep=1pt]
    {\footnotesize $2$} (w);
   \draw[thick,snake,myblue] (w) to node[xshift=4mm,yshift=2mm] {$>\!0$} (u);
  \end{tikzpicture}
  \caption{Případ (1). Cesta $\clb{\mathcal{P}}$ je značena modře. Množina
  $\clr{X}$ červeně. Nemůže nastat, pokud algoritmus běží správně.}
  \label{subfig:dukaz-dijkstra-pripad-1}
 \end{subfigure}
 \hfill
 \begin{subfigure}{.47\textwidth}
  \centering
  \begin{tikzpicture}
   \node[vertex,myred] (s) at (0,0) {};
   \node[vertex,myred] (v1) at (1,-2) {};
   \node[vertex,myred] (v2) at (2,-1) {};
   \node[vertex,myred] (v3) at (3,-1.5) {};
   \node[vertex,myred] (u) at (4,0) {};
   
   \node[below left=0mm and 0mm of s,myred] {$s$};
   \node[below right=0mm and 0mm of u,myred] {$u$};
   
   \node[vertex,myred] (p1) at (1.5,1.5) {};
   \node[vertex,myred] (w) at (3,1) {};
   \node[above right=0mm and 0mm of w,myred] {$w$};
   

   \draw[thick] (s) to node[midway,circle,draw,fill=white,inner sep=1pt]
    {\footnotesize $3$} (v1);
   \draw[thick] (v1) to node[midway,circle,draw,fill=white,inner sep=1pt]
    {\footnotesize $2$} (v2);
   \draw[thick] (v2) to node[midway,circle,draw,fill=white,inner sep=1pt]
    {\footnotesize $2$} (v3);
   \draw[thick] (v3) to node[midway,circle,draw,fill=white,inner sep=1pt]
    {\footnotesize $5$} (u);

   \draw[thick,myblue] (s) to node[midway,circle,draw,fill=white,inner sep=1pt]
    {\footnotesize $7$} (p1);
   \draw[thick,myblue] (p1) to node[midway,circle,draw,fill=white,inner sep=1pt]
    {\footnotesize $2$} (w);
   \draw[thick,myblue] (w) to node[midway,circle,draw,fill=white,inner sep=1pt]
    {\footnotesize $2$} (u);
  \end{tikzpicture}
  \caption{Případ (2). Cesta $\clb{\mathcal{P}}$ je značena modře. Množina
  $\clr{X}$ červeně. Nemůže nastat, pokud algoritmus běží správně.}
  \label{subfig:dukaz-dijkstra-pripad-2}
 \end{subfigure}
 \caption{Obecný indukční krok v důkazu správnosti
 \hyperref[alg:dijkstra]{Dijkstrova algoritmu}.}
 \label{fig:dukaz-dijkstra}
\end{figure}

\subsubsection{Hurá na výlet}
\label{sssec:hura-na-vylet}

Sekci o vzdálenosti mezi vrcholy zakončíme popisem algoritmu řešícím
\hyperref[prob:rodinny-vylet]{úlohu o rodinném výletu}. V jeho jádru je nalezení
nejkratší cesty mezi zvolenými vrcholy, čili \hyperref[alg:dijkstra]{Dijkstrův
algoritmus} zde zcela jistě najde své využití. Co ovšem s hospodami? Zadání
úlohy stanovuje, že nám nestačí nalézt pouze nejkratší cestu z \clr{Třince} do
\clb{Orlové}, nýbrž z množiny všech nejkratších cest vybrat tu, jež je tak
daleko od hospod, jak to jen lze -- v tom smyslu, že minimum vzdáleností od
vrcholů cesty k hospodám je největší možné.

Poslední věta předchozího odstavce napovídá, že vzdálenost k hospodě máme vnímat
jako \emph{vlastnost konkrétního vrcholu}. Zcela jistě není vhodné obě části
úlohy (tedy nalezení nejkratší cesty a té, která se nejvíce vyhýbá hospodám)
oddělovat. Uvažme totiž případ, kdy \textbf{všechny} cesty mezi \clr{Třincem} a
\clb{Orlovou} jsou stejně dlouhé. Potom by postup
\begin{enumerate}
 \item Najdi všechny nejkratší cesty.
 \item Vyber z nich tu nejdál od hospod.
\end{enumerate}
vyžadoval prozkoumání všech možných cest, čemuž se z již párkrát diskutovaných
důvodů chceme vyhnout.

Řádově rychlejší postup bude tedy cestu nejdál od hospod hledat současně s tou
nejkratší. Abychom toto mohli udělat, musíme znát vzdálenost každého vrcholu od
nejbližší hospody. To lze snadno zařídit spuštěním
\hyperref[alg:dijkstra]{Dijkstrova algoritmu} vícekrát s každou hospodou jako
zdrojovým vrcholem.

Formálně, ať $H = \{h_1,\ldots,h_k\} \subseteq V$ značí množinu hospod. Pro
každé $i \leq k$ máme z výstupu Dijkstrova algoritmu zobrazení $\theta_i:V \to
[0,\infty]$ takové, že $\theta_i(v) = d_G(h_i,v)$ pro každý $v \in V$. Nyní již
snadno využijeme zobrazení $\theta_i$ k definici zobrazení $\Theta:V \to
[0,\infty]$, které značí pro každý vrchol jeho vzdálenost k nejbližší hospodě.
Uvědomme si, že stačí definovat
\[
 \Theta(v) \coloneqq \min_{i \leq k} \theta_i(v) \quad \forall v \in V.
\]
Druhá část řešení bude též spočívat ve spuštění Dijkstrova algoritmu, a\-však s
mírnými úpravami. Zamysleme, jak bychom mohli během jednoho průchodu vrcholem
porovnat váhu a vzdálenost od hospody v něm uložených údajů o cestě s těmi o té,
po které jsme do něj právě přišli. To ve skutečnosti není vůbec složité. Přeci,
primárně nám jde o to najít nejkratší cestu. Vzdálenost k hospodám řešíme až v
moment, kdy by dvě různé cesty měly být stejně dlouhé. Stačí pročež vždy nejprve
porovnat váhy cest do vrcholu vedoucích, a teprve když se rovnají, porovnat též
jejich vzdálenosti k hospodám.

Navíc k zobrazení $d$ a množině $X$ (z popisu \hyperref[alg:dijkstra]{Dijkstrova
algoritmu}) si u každého vrcholu musíme pamatovat cestu, po které jsme do něj
přišli. A k těmto cestám též jejich vzdálenosti od hospod. Pro tento účel si
zavedeme zobrazení $P:V \to \bigcup_{i = 0}^{n} V^{i}$, čili zobrazení, které
každému vrcholu přiřadí $m$-tici (pro nějaké $m \leq n$) vrcholů představující
cestu, kterou jsem se do něj dostal. Na začátku máme $P(v) = \emptyset$ pro
všechny vrcholy $v \in V$. Je-li $\mathcal{P} = v_1\cdots v_k$, pak výrazem
$\mathcal{P} \oplus u$ myslíme cestu $v_1\cdots v_k u$; pochopitelně pouze za
předpokladu, že $v_ku \in E$. Konečně, výrazem $h(\mathcal{P})$ budeme chápat
vzdálenost cesty $\mathcal{P}$ k hospodám, tj. minimum přes všechny vrcholy z
jejich vzdáleností k nejbližší hospodě. Formálně
\[
 h(\mathcal{P}) \coloneqq \min_{v \in \mathcal{P}} \Theta(v).
\]
Zobrazení $h$ budeme též v průběhu algoritmu vytvářet, neboť v opačném případě
bychom museli při vchodu do nového vrcholu pokaždé procházet všechny vrcholy
obou porovnávaných cest. Je-li totiž $\mathcal{P} = v_1\cdots v_k$ a $v_ku \in
E$, pak $h(\mathcal{P} \oplus u)$ je buď $h(\mathcal{P})$, pokud je $u$ od
hospod dál než aspoň jeden vrchol v $\mathcal{P}$. V opačném případě je
$h(\mathcal{P} \oplus u) = \Theta(u)$. Souhrnně, vždy máme
\[
 h(\mathcal{P} \oplus u) = \min(h(\mathcal{P}),\Theta(u)).
\]

Přicházíme ke slovnímu popisu řešení \hyperref[prob:rodinny-vylet]{úlohy o
rodinném výletu}. Počáteční vrchol představující město \clr{Třinec} značíme
\clr{$t$} a koncový vrchol představující město \clb{Orlová} značíme \clb{$o$}.

\begin{enumerate}
 \item Polož $d(\clr{t}) \coloneqq 0$ a $d(v) \coloneqq \infty$ pro všechny
  ostatní vrcholy $v \neq \clr{t}$. Dále polož $X \coloneqq \emptyset$,
  $P(\clr{t}) \coloneqq \clr{t}$ a $P(v) = \emptyset$ pro všechny ostatní
  vrcholy $v \neq \clr{t}$. Konečně, polož $h(P(\clr{t})) \coloneqq
  \Theta(\clr{t})$.
 \item Vyber libovolný vrchol $v \in V$ s minimální $d(v)$.
 \item Projdi všechny sousedy $u$ vrcholu $v$, které nejsou v $X$.
 \begin{enumerate}
  \item Je-li $d(u) > d(v) + w(uv)$ nebo
  \item $d(u) = d(v) + w(uv)$ a zároveň $\min(h(P(u)),\Theta(v)) >
   h(P(v))$, pak polož
   \begin{itemize}
    \item $d(u) \coloneqq d(v) + w(uv)$,
    \item $P(u) \coloneqq P(v) \oplus u$,
    \item $h(P(u)) \coloneqq \min(h(P(v)), \Theta(u))$.
   \end{itemize}
  \item V ostatních případech nedělej nic.
 \end{enumerate}
 \item Zakaž vrchol $v$, tj. přidej ho do $X$.
 \item Pokud $\clb{o} \notin X$, opakuj bod (2).
\end{enumerate}

\begin{remark}
 Bod (3) je jádrem popsaného algoritmu. Lidsky řečeno znamenají jeho body (a) a
 (b) následující.
 \begin{enumerate}[label=(\alph*)]
  \item Do $u$ vede přes $v$ kratší cesta, než ta zatím známá.
  \item Do $u$ vede přes $v$ stejně dlouhá cesta, jako ta zatím známá, ale navíc
   je vzdálenost této nové cesty k hospodě větší než vzdálenost k hospodě té
   zatím známé.
 \end{enumerate}
 Toto přesně znamená, že primárně nás zajímá váha cesty, sekundárně pak její
 vzdálenost k hospodě. V obou případech (a) i (b) pak vlastně jenom přepíšeme
 dosavadní cestu do $u$. To jest, zapamatujeme si ji samotnou ($P(v) \oplus u$),
 její váhu ($d(v) + w(uv)$) a, konečně, její vzdálenost k hospodě; ta zůstane
 přirozeně stejná, pokud je nějaký vrchol $P(v)$ blíž k hospodě než $u$, v
 opačném případě se změní na $\Theta(u)$, čili na vzdálenost $u$ k nejbližší
 hospodě.
\end{remark}

Celou sekci završíme \hyperref[alg:rodinny-vylet]{pseudokódem} řešícím trable
dědy Koláčka.

\begin{algorithm}
  \caption{Řešení \hyperref[prob:rodinny-vylet]{úlohy o rodinném výletu}}
  \label{alg:rodinny-vylet}

  \SetKwInOut{Input}{input}
  \SetKwInOut{Output}{output}
  \SetKw{KwReturn}{return}
  \SetKw{KwAnd}{and}
  \SetKw{KwOr}{or}

  \Input{Souvislý ohodnocený graf $G = (V,E,w)$, zdrojový vrchol $\clr{t}$,
   koncový vrchol $\clb{o}$, podmnožina $\clp{H} \subseteq V$ a zobrazení
   $\Theta:V \to [0,\infty]$ takové, že $\Theta(v) = \min_{u \in
   \clp{H}}d_G(v,u) \; \forall v \in V$.}
  \Output{Nejkratší cesta $P(\clb{o})$ mezi $\clr{t}$ a $\clb{o}$, její
   váha $d(\clb{o})$ a její vzdálenost k nejbližší hospodě $h(P(\clb{o}))$.}
  \BlankLine
  \emph{Inicializace}\;
  $d(\clr{t}) \leftarrow 0$\;
  $P(\clr{t}) \leftarrow \clr{t}$\;
  $h(P(\clr{t})) \leftarrow \Theta(\clr{t})$\;
  \For{$v \in V \setminus \{\clr{t}\}$} {
   $d(v) \leftarrow \infty$\;
   $P(v) \leftarrow \emptyset$\;
   $h(P(v)) \leftarrow 0$\;
  }
  $X \leftarrow \emptyset$\;
  \BlankLine
  \emph{Pokračuj, dokud vrchol $\clb{o}$ není zakázaný. Tedy do něj ještě
  neznáme nejkratší cestu}\;
  \While{$\clb{o} \notin X$} {
   \emph{Vezmi nezakázaný vrchol s minimální známou vzdáleností}\;
   $v \leftarrow $ vrchol takový, že $d(v) = \min_{u \in V \setminus X} d(u)$ a
   $v \notin X$\;
   \emph{Projdi jeho nezakázané sousedy}\;
   \For{$u \in n(v) \setminus X$} {
    \emph{Když současná cesta zlepšuje známou vzdálenost od $\clr{t}$ nebo ji
    zachovává a zlepšuje vzdálenost od hospod, aktualizuj ji}\;
    \If{$(d(u) > d(v) + w(uv))$ \KwOr\\
    $(d(u) = d(v) + w(uv)$ \KwAnd $\min(h(P(v)),\Theta(u)) > P(u))$} {
     $d(u) \leftarrow d(v) + w(uv)$\;
     $P(u) \leftarrow P(v) \oplus u$\;
     $h(P(u)) \leftarrow \min(h(P(v)),\Theta(u))$\;
    }
    \emph{Zakaž vrchol $v$}\;
    $X \leftarrow X \cup \{v\}$\;
   }
   \KwReturn $P(\clb{o}),d(\clb{o}),h(P(\clb{o}))$\;
  }
\end{algorithm}

\pagebreak

\begin{exercise}
 Vyřešte \hyperref[prob:rodinny-vylet]{úlohu o rodinném výletu} pro graf daný
 \myref{obrázkem}{fig:trinec-orlova}.
\end{exercise}
